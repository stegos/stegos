//
// Copyright (c) 2019 Stegos AG
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use super::protocol::{ReplicationCodec, ReplicationConfig, ReplicationVersion};

use futures::prelude::*;
use futures::sink::SinkExt;
use futures::task::{Context, Poll};
use libp2p_core::upgrade::{InboundUpgrade, OutboundUpgrade};
use libp2p_swarm::protocols_handler::{
    KeepAlive, ProtocolsHandler, ProtocolsHandlerEvent, ProtocolsHandlerUpgrErr, SubstreamProtocol,
};
use libp2p_swarm::NegotiatedSubstream;

use log::*;
use std::fmt;
use std::io;
use std::io::ErrorKind;
use std::pin::Pin;

use derivative::Derivative;
use futures::channel::mpsc;
use futures_codec::Framed;

const INPUT_BUFFER_SIZE: usize = 10;
const OUTPUT_BUFFER_SIZE: usize = 10;

/// Events consumed to ReplicationHandler.
/// Sic: this structure is `pub` because it doesn't compile otherwise.
#[derive(Debug, Clone)]
pub enum HandlerInEvent {
    Connect,
    Disconnect,
}

/// Events generated by ReplicationHandler.
#[derive(Debug)]
pub enum HandlerOutEvent {
    ResolvedVersion {
        version: ReplicationVersion,
    },
    Connected {
        tx: mpsc::Sender<Vec<u8>>,
        rx: mpsc::Receiver<Vec<u8>>,
    },
    ConnectionFailed {
        error: io::Error,
    },
    Accepted {
        tx: mpsc::Sender<Vec<u8>>,
        rx: mpsc::Receiver<Vec<u8>>,
    },
}

/// State of an active substream, opened either by us or by the remote.
/// Sic: this structure is `pub` because it doesn't compile otherwise.
#[derive(Derivative)]
#[derivative(Debug)]
enum SubstreamState {
    /// A new peer.
    Registered,
    /// Peer is connecting to a remote side.
    Connecting,
    /// Peer was disconnected.
    Disconnected,
    /// Connection to a remote side has been failed.
    /// This is a transitional state for inject_dial_upgrade_error().
    ConnectionFailed { error: io::Error },
    /// Connected to a remote side.
    Connected {
        protocol: Framed<NegotiatedSubstream, ReplicationCodec>,
    },
    /// Accepted a remote side.
    Accepted {
        protocol: Framed<NegotiatedSubstream, ReplicationCodec>,
    },
    /// Forwarding network <-> mpsc::channel().
    /// Sic: Rust doesn't support Box::new() for <T> type.
    Forwarding {
        #[derivative(Debug = "ignore")]
        rx_forward: Pin<Box<dyn Future<Output = Result<(), io::Error>> + Send>>,
        #[derivative(Debug = "ignore")]
        tx_forward: Pin<Box<dyn Future<Output = Result<(), io::Error>> + Send>>,
    },
}

impl SubstreamState {
    fn poll_unpin(
        &mut self,
        cx: &mut Context,
    ) -> Poll<(mpsc::Sender<Vec<u8>>, mpsc::Receiver<Vec<u8>>)> {
        match self {
            SubstreamState::Registered
            | SubstreamState::Disconnected
            | SubstreamState::Connecting => Poll::Pending,
            SubstreamState::Connected { .. } | SubstreamState::Accepted { .. } => {
                let protocol = match std::mem::replace(self, SubstreamState::Registered) {
                    SubstreamState::Connected { protocol }
                    | SubstreamState::Accepted { protocol } => protocol,
                    _ => unreachable!("Expected Connected|Accepted state"),
                };

                let (net_tx, net_rx) = protocol.split();
                let (node_tx, rx) = mpsc::channel::<Vec<u8>>(INPUT_BUFFER_SIZE);
                let (tx, node_rx) = mpsc::channel::<Vec<u8>>(OUTPUT_BUFFER_SIZE);
                let node_tx =
                    node_tx.sink_map_err(|_e| io::Error::new(ErrorKind::Other, "forward error"));
                let node_rx = node_rx.map(Ok);
                let rx_forward = Box::pin(net_rx.forward(node_tx));
                let tx_forward = Box::pin(node_rx.forward(net_tx));

                let rx_forward =
                    rx_forward as Pin<Box<dyn Future<Output = Result<(), io::Error>> + Send>>;
                let tx_forward =
                    tx_forward as Pin<Box<dyn Future<Output = Result<(), io::Error>> + Send>>;

                let state = SubstreamState::Forwarding {
                    rx_forward,
                    tx_forward,
                };
                *self = state;
                Poll::Ready((tx, rx))
            }
            SubstreamState::Forwarding {
                tx_forward,
                rx_forward,
            } => match tx_forward.poll_unpin(cx) {
                Poll::Ready(Ok(())) => {
                    *self = SubstreamState::Registered;
                    Poll::Pending
                }
                Poll::Pending => match rx_forward.poll_unpin(cx) {
                    Poll::Ready(Ok(())) => {
                        *self = SubstreamState::Registered;
                        Poll::Pending
                    }
                    Poll::Ready(Err(error)) => {
                        error!("rx error: {:?}", error);
                        *self = SubstreamState::Registered;
                        Poll::Pending
                    }
                    Poll::Pending => Poll::Pending,
                },
                Poll::Ready(Err(error)) => {
                    error!("tx error: {:?}", error);
                    *self = SubstreamState::Registered;
                    Poll::Pending
                }
            },
            SubstreamState::ConnectionFailed { .. } => {
                // Transitional state for inject_dial_upgrade_error().
                unreachable!("ConnectionFailed is handled by upper level");
            }
        }
    }
}

pub struct ReplicationHandler {
    /// Configuration for the floodsub protocol.
    config: ReplicationConfig,

    upstream: SubstreamState,
    downstream: SubstreamState,
    resolved_version: Option<ReplicationVersion>,
}

impl ReplicationHandler {
    /// Builds a new `ReplicationHandler`.
    pub fn new() -> Self {
        ReplicationHandler {
            config: ReplicationConfig::new(),
            upstream: SubstreamState::Registered,
            downstream: SubstreamState::Registered,
            resolved_version: None,
        }
    }
}

impl Default for ReplicationHandler {
    fn default() -> Self {
        Self::new()
    }
}

impl ProtocolsHandler for ReplicationHandler {
    type InEvent = HandlerInEvent;
    type OutEvent = HandlerOutEvent;
    type Error = io::Error;
    type InboundProtocol = ReplicationConfig;
    type OutboundProtocol = ReplicationConfig;
    type OutboundOpenInfo = ();

    #[inline]
    fn listen_protocol(&self) -> SubstreamProtocol<Self::InboundProtocol> {
        SubstreamProtocol::new(self.config.clone())
    }

    fn inject_fully_negotiated_inbound(
        &mut self,
        protocol: <Self::InboundProtocol as InboundUpgrade<NegotiatedSubstream>>::Output,
    ) {
        // Take version from codec
        let (inner, codec) = protocol.release();
        self.resolved_version = Some(codec.version);
        let protocol = Framed::new(inner, codec);

        match self.downstream {
            SubstreamState::Registered | SubstreamState::ConnectionFailed { .. } => {
                debug!("Accepted");
                self.downstream = SubstreamState::Accepted { protocol };
            }
            _ => {
                debug!("Rejected");
            }
        }
    }

    fn inject_fully_negotiated_outbound(
        &mut self,
        protocol: <Self::OutboundProtocol as OutboundUpgrade<NegotiatedSubstream>>::Output,
        _open_info: Self::OutboundOpenInfo,
    ) {
        // Take version from codec
        let (inner, codec) = protocol.release();
        self.resolved_version = Some(codec.version);
        let protocol = Framed::new(inner, codec);

        match self.upstream {
            SubstreamState::Connecting => {
                debug!("Connected");
                self.upstream = SubstreamState::Connected { protocol };
            }
            _ => {
                debug!("Disconnect");
            }
        }
    }

    #[inline]
    fn inject_event(&mut self, event: Self::InEvent) {
        trace!("Inject event: event={:?}", event);
        match event {
            HandlerInEvent::Connect => {
                debug!("Connecting");
                self.upstream = SubstreamState::Registered;
            }
            HandlerInEvent::Disconnect => {
                debug!("Disconnecting");
                self.upstream = SubstreamState::Disconnected;
            }
        }
    }

    #[inline]
    fn inject_dial_upgrade_error(
        &mut self,
        _: Self::OutboundOpenInfo,
        e: ProtocolsHandlerUpgrErr<
            <Self::OutboundProtocol as OutboundUpgrade<NegotiatedSubstream>>::Error,
        >,
    ) {
        trace!("Connection failed: {}", e);
        match self.upstream {
            SubstreamState::Connecting => {}
            _ => return, // Ignore this error.
        }
        let error = io::Error::new(io::ErrorKind::Other, e);
        self.upstream = SubstreamState::ConnectionFailed { error };
    }

    #[inline]
    fn connection_keep_alive(&self) -> KeepAlive {
        KeepAlive::Yes
    }

    fn poll(
        &mut self,
        cx: &mut Context,
    ) -> Poll<
        ProtocolsHandlerEvent<
            Self::OutboundProtocol,
            Self::OutboundOpenInfo,
            Self::OutEvent,
            Self::Error,
        >,
    > {
        trace!("Poll = {:?}", self.upstream);
        if let SubstreamState::Registered = &self.upstream {
            // Create a new substream.
            self.upstream = SubstreamState::Connecting;
            return Poll::Ready(ProtocolsHandlerEvent::OutboundSubstreamRequest {
                info: (),
                protocol: SubstreamProtocol::new(self.config.clone()),
            });
        } else if let SubstreamState::ConnectionFailed { .. } = &self.upstream {
            // Substream creation failed.
            let error = match std::mem::replace(&mut self.upstream, SubstreamState::Registered) {
                SubstreamState::ConnectionFailed { error } => error,
                _ => unreachable!("Expected ConnectionFailed state"),
            };
            return Poll::Ready(ProtocolsHandlerEvent::Custom(
                HandlerOutEvent::ConnectionFailed { error },
            ));
        };

        if let Some(version) = self.resolved_version.take() {
            debug!("Send resolved version event.");
            return Poll::Ready(ProtocolsHandlerEvent::Custom(
                HandlerOutEvent::ResolvedVersion { version },
            ));
        }

        if let Poll::Ready(r) = self.upstream.poll_unpin(cx) {
            let (tx, rx) = r;
            return Poll::Ready(ProtocolsHandlerEvent::Custom(HandlerOutEvent::Connected {
                rx,
                tx,
            }));
        }

        if let Poll::Ready(r) = self.downstream.poll_unpin(cx) {
            let (tx, rx) = r;
            return Poll::Ready(ProtocolsHandlerEvent::Custom(HandlerOutEvent::Accepted {
                rx,
                tx,
            }));
        }

        Poll::Pending
    }
}

impl fmt::Debug for ReplicationHandler {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        f.debug_struct("ReplicationHandler").finish()
    }
}
